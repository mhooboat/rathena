From 0bce4f7c74fb428155158e9cb3f970db2bd899e3 Mon Sep 17 00:00:00 2001
From: ex0ample <ex0ample@gmail.com>
Date: Fri, 22 Sep 2023 10:10:10 +0700
Subject: [PATCH] COLLECTION STORAGE SYSTEM V3

---
 conf/inter_server.yml                   |  3 ++
 conf/msg_conf/map_msg.conf              |  5 ++
 db/re/item_db_equip.yml                 |  2 +
 npc/custom/collection.txt               | 14 ++++++
 npc/scripts_custom.conf                 |  3 ++
 sql-files/custom/storage_collection.sql | 39 +++++++++++++++
 src/common/mmo.hpp                      |  2 +
 src/map/clif.cpp                        |  3 ++
 src/map/intif.cpp                       |  5 ++
 src/map/itemdb.cpp                      | 20 ++++++++
 src/map/itemdb.hpp                      |  7 +++
 src/map/pc.cpp                          | 63 +++++++++++++++++++++++++
 src/map/pc.hpp                          | 17 +++++++
 src/map/status.cpp                      | 12 +++++
 src/map/storage.cpp                     | 41 +++++++++++++++-
 15 files changed, 235 insertions(+), 1 deletion(-)
 create mode 100644 npc/custom/collection.txt
 create mode 100644 sql-files/custom/storage_collection.sql

diff --git a/conf/inter_server.yml b/conf/inter_server.yml
index ed6bc792d..6e23e3700 100644
--- a/conf/inter_server.yml
+++ b/conf/inter_server.yml
@@ -40,6 +40,9 @@ Body:
   - ID: 0
     Name: "Storage"
     Table: storage
+  - ID: 1
+    Name: "Collection"
+    Table: storage_collection
 
 Footer:
   Imports:
diff --git a/conf/msg_conf/map_msg.conf b/conf/msg_conf/map_msg.conf
index 49e09c276..9f0e39ac7 100644
--- a/conf/msg_conf/map_msg.conf
+++ b/conf/msg_conf/map_msg.conf
@@ -1815,5 +1815,10 @@
 1531: Invalid position.
 1532: Invalid slot number.
 
+1540: [Collection] Collection list %d ea.
+1541: [Collection] Update collection list %d ea.
+1542: [Collection] Item %s is not in collection.
+1543: [Collection] You have item %s in collection.
+
 //Custom translations
 import: conf/msg_conf/import/map_msg_eng_conf.txt
diff --git a/db/re/item_db_equip.yml b/db/re/item_db_equip.yml
index 92ab69057..a8cbbebf2 100644
--- a/db/re/item_db_equip.yml
+++ b/db/re/item_db_equip.yml
@@ -12908,6 +12908,8 @@ Body:
       bonus bVariableCastrate,-100;
       bonus bFixedCastrate,-100;
       bonus bAspdRate,100;
+    CollectionScript: |
+      bonus bAllStats,99;
   - Id: 1600
     AegisName: Sinister_Rod
     Name: Rod of Vicious Mind
diff --git a/npc/custom/collection.txt b/npc/custom/collection.txt
new file mode 100644
index 000000000..50680bbc2
--- /dev/null
+++ b/npc/custom/collection.txt
@@ -0,0 +1,14 @@
+//===== rAthena Script =======================================
+//= Ex0ample: Collection Sample
+//===== By: ==================================================
+//= rAthena Dev Team
+//===== Last Updated: ========================================
+//= 202309214
+//===== Description: ========================================= 
+//= Collection demonstrates.
+//============================================================
+
+prontera,157,181,4	script	Collection Sample	105,{
+	openstorage2 1,STOR_MODE_GET|STOR_MODE_PUT;
+	end;
+}
\ No newline at end of file
diff --git a/npc/scripts_custom.conf b/npc/scripts_custom.conf
index fb46627e4..f16103583 100644
--- a/npc/scripts_custom.conf
+++ b/npc/scripts_custom.conf
@@ -115,3 +115,6 @@
 // -- Custom quests from official Umbalian Quests
 //npc: npc/custom/quests/sphinx_mask.txt
 //npc: npc/custom/quests/umbalian_language.txt
+
+// --------------------- collection Scripts --------------------
+npc: npc/custom/collection.txt
\ No newline at end of file
diff --git a/sql-files/custom/storage_collection.sql b/sql-files/custom/storage_collection.sql
new file mode 100644
index 000000000..da9c9d3ce
--- /dev/null
+++ b/sql-files/custom/storage_collection.sql
@@ -0,0 +1,39 @@
+--
+-- Table structure for table `storage_collection`
+--
+
+CREATE TABLE IF NOT EXISTS `storage_collection` (
+  `id` int(11) unsigned NOT NULL auto_increment,
+  `account_id` int(11) unsigned NOT NULL default '0',
+  `nameid` int(10) unsigned NOT NULL default '0',
+  `amount` smallint(11) unsigned NOT NULL default '0',
+  `equip` int(11) unsigned NOT NULL default '0',
+  `identify` smallint(6) unsigned NOT NULL default '0',
+  `refine` tinyint(3) unsigned NOT NULL default '0',
+  `attribute` tinyint(4) unsigned NOT NULL default '0',
+  `card0` int(10) unsigned NOT NULL default '0',
+  `card1` int(10) unsigned NOT NULL default '0',
+  `card2` int(10) unsigned NOT NULL default '0',
+  `card3` int(10) unsigned NOT NULL default '0',
+  `option_id0` smallint(5) NOT NULL default '0',
+  `option_val0` smallint(5) NOT NULL default '0',
+  `option_parm0` tinyint(3) NOT NULL default '0',
+  `option_id1` smallint(5) NOT NULL default '0',
+  `option_val1` smallint(5) NOT NULL default '0',
+  `option_parm1` tinyint(3) NOT NULL default '0',
+  `option_id2` smallint(5) NOT NULL default '0',
+  `option_val2` smallint(5) NOT NULL default '0',
+  `option_parm2` tinyint(3) NOT NULL default '0',
+  `option_id3` smallint(5) NOT NULL default '0',
+  `option_val3` smallint(5) NOT NULL default '0',
+  `option_parm3` tinyint(3) NOT NULL default '0',
+  `option_id4` smallint(5) NOT NULL default '0',
+  `option_val4` smallint(5) NOT NULL default '0',
+  `option_parm4` tinyint(3) NOT NULL default '0',
+  `expire_time` int(11) unsigned NOT NULL default '0',
+  `bound` tinyint(3) unsigned NOT NULL default '0',
+  `unique_id` bigint(20) unsigned NOT NULL default '0',
+  `enchantgrade` tinyint unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`),
+  KEY `account_id` (`account_id`)
+) ENGINE=MyISAM;
\ No newline at end of file
diff --git a/src/common/mmo.hpp b/src/common/mmo.hpp
index cabf20d94..6d7abbb4f 100644
--- a/src/common/mmo.hpp
+++ b/src/common/mmo.hpp
@@ -1192,4 +1192,6 @@ struct clan{
 	#define MAX_CARTS 5
 #endif
 
+#define COLLECTION_STORAGE 1
+
 #endif /* MMO_HPP */
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index 991b5b1b8..5d4db46f6 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -11062,6 +11062,9 @@ void clif_parse_LoadEndAck(int fd,map_session_data *sd)
 		if (!sd->state.autotrade) { // Don't trigger NPC event or opening vending/buyingstore will be failed
 			//Login Event
 			npc_script_event(sd, NPCE_LOGIN);
+
+			//Collection Event
+			pc_collection_load(*sd);
 		}
 
 		// Set facing direction before check below to update client
diff --git a/src/map/intif.cpp b/src/map/intif.cpp
index e5883f5fa..6ed4c3c7f 100644
--- a/src/map/intif.cpp
+++ b/src/map/intif.cpp
@@ -3477,6 +3477,11 @@ static bool intif_parse_StorageReceived(int fd)
 
 	memcpy(stor, p, sz_stor); //copy the items data to correct destination
 
+	if (stor->stor_id == COLLECTION_STORAGE && sd->state.collection_flag&PCCOLLECTION_LOAD) {
+		pc_collection_update(stor,*sd);
+		return true;
+	}
+
 	switch (type) {
 		case TABLE_INVENTORY: {
 #ifdef BOUND_ITEMS
diff --git a/src/map/itemdb.cpp b/src/map/itemdb.cpp
index c9cc886b8..d29d758aa 100644
--- a/src/map/itemdb.cpp
+++ b/src/map/itemdb.cpp
@@ -1108,6 +1108,26 @@ uint64 ItemDatabase::parseBodyNode(const ryml::NodeRef& node) {
 			item->unequip_script = nullptr;
 	}
 
+	if (this->nodeExists(node, "CollectionScript")) {
+		std::string script;
+
+		if (!this->asString(node, "CollectionScript", script))
+			return 0;
+
+		if (exists && item->collection_script) {
+			script_free_code(item->collection_script);
+			item->collection_script = nullptr;
+		}
+
+		item->collection_script = parse_script(script.c_str(), this->getCurrentFile().c_str(), this->getLineNumber(node["CollectionScript"]), SCRIPT_IGNORE_EXTERNAL_BRACKETS);
+		item->flag.collection = true;
+	} else {
+		if (!exists) {
+			item->collection_script = nullptr;
+			item->flag.collection = false;
+		}
+	}
+
 	if (!exists)
 		this->put(nameid, item);
 
diff --git a/src/map/itemdb.hpp b/src/map/itemdb.hpp
index a48823fba..b2a581216 100644
--- a/src/map/itemdb.hpp
+++ b/src/map/itemdb.hpp
@@ -2071,6 +2071,7 @@ struct item_data
 	struct script_code *script;	//Default script for everything.
 	struct script_code *equip_script;	//Script executed once when equipping.
 	struct script_code *unequip_script;//Script executed once when unequipping.
+	struct script_code *collection_script;	//Default script for collection.
 	struct {
 		unsigned available : 1;
 		uint32 no_equip;
@@ -2088,6 +2089,7 @@ struct item_data
 		bool bindOnEquip; ///< Set item as bound when equipped
 		e_item_drop_effect dropEffect; ///< Drop Effect Mode
 		unsigned gradable : 1;
+		bool collection;
 	} flag;
 	struct {// item stacking limitation
 		uint16 amount;
@@ -2120,6 +2122,11 @@ struct item_data
 			this->unequip_script = nullptr;
 		}
 
+		if (this->collection_script){
+			script_free_code(this->collection_script);
+			this->collection_script = nullptr;
+		}
+
 		this->combos.clear();
 	}
 
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index f67cd39eb..7ee2519de 100755
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -15798,6 +15798,69 @@ uint64 CaptchaDatabase::parseBodyNode(const ryml::NodeRef &node) {
 	return 1;
 }
 
+void pc_collection_load(map_session_data &sd) {
+	if (!storage_exists(COLLECTION_STORAGE)) {
+		return;
+	}
+
+	sd.state.collection_flag |= PCCOLLECTION_LOAD;
+
+	storage_premiumStorage_load(&sd, COLLECTION_STORAGE, STOR_MODE_NONE);
+}
+
+void pc_collection_update(struct s_storage *stor, map_session_data &sd) {
+	nullpo_retv(stor);
+
+	char output[128];
+
+	if (stor->stor_id != COLLECTION_STORAGE) {
+		return;
+	}
+	
+	if (sd.state.collection_flag &(PCCOLLECTION_LOAD|PCCOLLECTION_RECAL)) {
+		
+		// reset data
+		sd.collection_list.clear();
+
+		// update data
+		for (int i = 0; i < stor->max_amount; i++) {
+
+			std::shared_ptr<item_data> id = item_db.find(stor->u.items_storage[i].nameid);
+			int amount = stor->u.items_storage[i].amount;
+
+			if (!id || !amount) {
+				continue;
+			}
+
+			if (!id->flag.collection) {
+				ShowError("pc_collection_update_bind: Item %s(%d) invalid type.", id->ename.c_str(), id->nameid);
+				storage_storageget(&sd, stor, i, amount);
+				continue;
+			}
+
+			if (rathena::util::vector_exists(sd.collection_list, id->nameid)) {
+				ShowError("pc_collection_update_bind: Item %s(%d) duplicate bonus.", id->ename.c_str(), id->nameid);
+
+				continue;
+			}
+
+			sd.collection_list.push_back(id->nameid);
+		}
+	}
+
+	if (sd.state.collection_flag&PCCOLLECTION_RELOAD) {
+		clif_inventorylist(&sd);
+	}
+
+	if ((sd.state.collection_flag&PCCOLLECTION_LOAD && sd.collection_list.size() > 0) || sd.state.collection_flag&PCCOLLECTION_RECAL) {
+		sprintf(output, msg_txt(&sd,(sd.state.collection_flag&PCCOLLECTION_LOAD ? 1540 : 1541)), sd.collection_list.size());
+		clif_messagecolor(&sd.bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		status_calc_pc(&sd, SCO_FORCE);
+	}
+
+	sd.state.collection_flag = PCCOLLECTION_CLEAR;
+}
+
 /*==========================================
  * pc Init/Terminate
  *------------------------------------------*/
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index c37cd4fb5..aa8dbeede 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -289,6 +289,17 @@ enum e_autospell_flags{
 	AUTOSPELL_FORCE_ALL = 0x3
 };
 
+/**
+ * Player blocking actions related flags.
+ */
+enum e_collection_flag : uint16 {
+	PCCOLLECTION_CLEAR    = 0x00,
+	PCCOLLECTION_LOAD     = 0x01,
+	PCCOLLECTION_RELOAD   = 0x02,
+	PCCOLLECTION_RECAL    = 0x04,
+	PCCOLLECTION_ALL  	  = 0x07,
+};
+
 /// AutoSpell bonus struct
 struct s_autospell {
 	uint16 id, lv, trigger_skill;
@@ -455,6 +466,7 @@ public:
 		bool roulette_open;
 		t_itemid item_reform;
 		uint64 item_enchant_index;
+		unsigned int collection_flag : 5;
 	} state;
 	struct {
 		unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
@@ -941,6 +953,8 @@ public:
 	s_macro_detect macro_detect;
 
 	std::vector<uint32> party_booking_requests;
+
+	std::vector<t_itemid> collection_list;
 };
 
 extern struct eri *pc_sc_display_ers; /// Player's SC display table
@@ -1752,4 +1766,7 @@ void pc_macro_reporter_process(map_session_data &sd, int32 reporter_account_id =
 void pc_reputation_generate();
 #endif
 
+void pc_collection_load(map_session_data &sd);
+void pc_collection_update(struct s_storage* stor, map_session_data& sd);
+
 #endif /* PC_HPP */
diff --git a/src/map/status.cpp b/src/map/status.cpp
index 6b0dc124b..c933e0b36 100644
--- a/src/map/status.cpp
+++ b/src/map/status.cpp
@@ -4027,6 +4027,18 @@ int status_calc_pc_sub(map_session_data* sd, uint8 opt)
 		current_equip_opt_index = -1;
 	}
 
+	if (sd->collection_list.size() > 0) {
+		for (auto &nameid : sd->collection_list ) {
+			std::shared_ptr<item_data> data = item_db.find(nameid);
+			if (data && data->flag.collection && data->collection_script) {
+				run_script(data->collection_script, 0, sd->bl.id, 0);
+			}
+		}
+		if (!calculating) {
+			return 1;
+		}
+	}
+
 	if (sc->count && sc->getSCE(SC_ITEMSCRIPT)) {
 		std::shared_ptr<item_data> data = item_db.find(sc->getSCE(SC_ITEMSCRIPT)->val1);
 
diff --git a/src/map/storage.cpp b/src/map/storage.cpp
index 5f59a2601..30e0c955e 100644
--- a/src/map/storage.cpp
+++ b/src/map/storage.cpp
@@ -203,6 +203,33 @@ static enum e_storage_add storage_canAddItem(struct s_storage *stor, int idx, st
 	if (!stor->state.put)
 		return STORAGE_ADD_NOACCESS;
 
+	if (stor->stor_id == COLLECTION_STORAGE) {
+		std::shared_ptr<item_data> data = item_db.find(items[idx].nameid);
+		map_session_data *sd = map_id2sd(stor->id);
+		char output[128];
+		int i;
+
+		if (!data || !sd) {
+			return STORAGE_ADD_INVALID;
+		}
+
+		if (!data->flag.collection) {
+			sprintf(output, msg_txt(sd, 1542), item_db.create_item_link(data).c_str());
+			clif_messagecolor(&sd->bl, color_table[COLOR_RED], output, false, SELF);
+			sd->state.collection_flag |= PCCOLLECTION_RELOAD;
+			return STORAGE_ADD_INVALID;
+		}
+
+		ARR_FIND(0, stor->max_amount, i, stor->u.items_storage[i].nameid == data->nameid);
+
+		if (i < stor->max_amount) {
+			sprintf(output, msg_txt(sd, 1543), item_db.create_item_link(data).c_str());
+			clif_messagecolor(&sd->bl, color_table[COLOR_RED], output, false, SELF);
+			sd->state.collection_flag |= PCCOLLECTION_RELOAD;
+			return STORAGE_ADD_INVALID;
+		}
+	}
+
 	return STORAGE_ADD_OK;
 }
 
@@ -293,6 +320,10 @@ static int storage_additem(map_session_data* sd, struct s_storage *stor, struct
 	clif_storageitemadded(sd,&stor->u.items_storage[i],i,amount);
 	clif_updatestorageamount(sd, stor->amount, stor->max_amount);
 
+	// add item to collection
+	if (stor->stor_id == COLLECTION_STORAGE) {
+		sd->state.collection_flag |= PCCOLLECTION_RECAL;
+	}
 	return 0;
 }
 
@@ -312,6 +343,10 @@ int storage_delitem(map_session_data* sd, struct s_storage *stor, int index, int
 	stor->dirty = true;
 
 	if( stor->u.items_storage[index].amount == 0 ) {
+		// remove item form collection
+		if (stor->stor_id == COLLECTION_STORAGE) {
+			sd->state.collection_flag |= PCCOLLECTION_RECAL;
+		}
 		memset(&stor->u.items_storage[index],0,sizeof(stor->u.items_storage[0]));
 		stor->amount--;
 		if( sd->state.storage_flag == 1 || sd->state.storage_flag == 3 )
@@ -1147,7 +1182,7 @@ bool storage_premiumStorage_load(map_session_data *sd, uint8 num, uint8 mode) {
 		return 0;
 	}
 
-	if (sd->premiumStorage.stor_id != num)
+	if (sd->premiumStorage.stor_id != num || sd->state.collection_flag&PCCOLLECTION_LOAD)
 		return intif_storage_request(sd, TABLE_STORAGE, num, mode);
 	else {
 		sd->premiumStorage.state.put = (mode&STOR_MODE_PUT) ? 1 : 0;
@@ -1187,6 +1222,10 @@ void storage_premiumStorage_close(map_session_data *sd) {
 		sd->state.storage_flag = 0;
 		clif_storageclose( sd );
 	}
+
+	if (sd->state.collection_flag&(PCCOLLECTION_RELOAD|PCCOLLECTION_RECAL)) {
+		pc_collection_update(&sd->premiumStorage, *sd);
+	}
 }
 
 /**
-- 
2.40.1.windows.1

